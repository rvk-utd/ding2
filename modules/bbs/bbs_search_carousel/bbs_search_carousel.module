<?php

/**
 * @file
 * Carousel panels pane. Based on ting_search_carousel.
 */

// The number of covers returned in each chunk.
define('BBS_SEARCH_CAROUSEL_CHUNK_SIZE', 8);

// Number of search results processed for covers at a time.
define('BBS_SEARCH_CAROUSEL_SEARCH_SIZE', 20);

/**
 * Implements hook_menu().
 */
function bbs_search_carousel_menu() {
  $items = array();

  $items['bbs_search_carousel/results/ajax/%/%/%'] = array(
    'title' => 'Show search carousel results',
    'page callback' => 'bbs_search_carousel_result',
    'page arguments' => array(3, 4, 5),
    'access arguments' => array('access content'),
    'file' => 'bbs_search_carousel.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function bbs_search_carousel_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' || $module == 'panels') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Get ting entities that has covers.
 *
 * Returns sets of entities by looping through search result and collecting
 * materials with covers. Internally caches and processes the search result in
 * chunks as needed.
 *
 * @param string $query
 *   The query to use.
 * @param int $start
 *   Start offset.
 * @param int $count
 *   Number to return.
 * @param bool $query_only
 *   Whether to only consult the already cached data.
 *
 * @return array
 *   Array with the keys 'entities', an array of ting entities, and
 *   'next_offset', which is the next offset to use or -1.
 */
function bbs_search_carousel_get_entities($query, $start, $count, $query_only = FALSE) {
  $query_id = md5($query);
  $cache_data = array(
    // All found covers.
    'pool' => array(),
    // Lookup table of seen IDs for this search.
    'all_ids' => array(),
    // Whether we've gone through all pages in the search result.
    'finished' => FALSE,
    // Next page to process.
    'search_page' => 0,
    // Size of each page.
    'search_page_size' => BBS_SEARCH_CAROUSEL_SEARCH_SIZE,
  );

  if ($cache = cache_get("bbs_search_carousel_search_" . $query_id)) {
    $cache_data = $cache->data;
  }

  $slice = _bbs_search_carousel_get_slice($cache_data, $start, $count);
  if ($query_only || $slice['next_offset'] != $start) {
    return $slice;
  }
  else {
    $lock_name = 'bbs_search_carousel_index_' . $query_id;
    // Use a lock to avoid stampedes.
    if (!lock_acquire($lock_name, 30)) {
      // We don't care if the lock is available or not, we'll just check if the
      // desired chunk has appeared or return an empty result.
      lock_wait($lock_name, 5);
      if ($cache = cache_get("bbs_search_carousel_search_" . $query_id)) {
        if (isset($cache->data)) {
          $cache_data = $cache->data;
          return _bbs_search_carousel_get_slice($cache_data, $start, $count);
        }
      }
    }

    // If the pool exactly matches the requested items, we'll fetch the next
    // chunk. Else search_page wouldn't get incremented.
    while ((count($cache_data['pool']) <= $start + $count) &&
      !$cache_data['finished']) {
      $ignore_ids = $cache_data['all_ids'];

      // Search well for materials with covers.
      list($found_entities, $cache_data['search_page'], $cache_data['finished'])
        = _bbs_search_carousel_find_entities_with_covers($query,
          $cache_data['search_page'],
          $cache_data['search_page_size'],
          $ignore_ids);

      foreach ($found_entities as $id => $entities) {
        $ignore_ids[$id] = TRUE;
        $cache_data['pool'][] = $entities;
      }
    }

    cache_set("bbs_search_carousel_search_" . $query_id, $cache_data);
    lock_release($lock_name);

    return _bbs_search_carousel_get_slice($cache_data, $start, $count);
  }
}

/**
 * Get a slice of cached cover data.
 *
 * @param array $cache_data
 *   The cached data to use.
 * @param int $start
 *   The start number to start the slice.
 * @param int $count
 *   The number of items to find.
 *
 * @return array
 *   Ting entities that has covers.
 */
function _bbs_search_carousel_get_slice(array $cache_data, $start, $count) {
  $pool_size = count($cache_data['pool']);
  // All inside our already collected data.
  if (($start + $count) <= $pool_size) {
    return array(
      'entities' => array_slice($cache_data['pool'], $start, $count),
      'next_offset' => $start + $count,
    );
  }
  // No more data to be fetched. Return the rest or nothing if $start is beyond
  // the end of data.
  elseif ($cache_data['finished']) {
    return array(
      'entities' => $start < $pool_size ? array_slice($cache_data['pool'], $start) : array(),
      'next_offset' => -1,
    );
  }
  // Not inside, and we're not finished yet.
  else {
    return array(
      'entities' => array(),
      'next_offset' => $start,
    );
  }
}

/**
 * Find ting entities with covers from a query.
 *
 * @param string $query
 *   Query to use.
 * @param int $start
 *   Offset to start from.
 * @param int $size
 *   Search chunk size to use.
 * @param array $ignore
 *   Material ids to skip.
 *
 * @return array
 *   Array of found ting entities (an array), next start to use, and whether
 *   the result end was reached.
 */
function _bbs_search_carousel_find_entities_with_covers($query, $start, $size, array $ignore) {
  $entities_found_with_covers = array();
  $finished = FALSE;
  $entities = array();

  // Search offset must be divisible by chunk size.
  // We cannot map a situation where offset is not divisible by chunk size to
  // the search abstraction layer paging model.
  if (!$start % $size === 0) {
    throw new InvalidArgumentException('Offset to start from % search chunk size should not have remainders left.');
  }

  // Determine what page we are on based on the start position and size.
  // Start is 0 indexed while page number is 1 indexed.
  $page = floor($start / $size) + 1;

  $sal_query = ting_start_query()
    ->withRawQuery($query)
    ->withPage($page)
    ->withCount($size)
    ->withPopulateCollections(FALSE)
    ->withMaterialFilter($ignore, FALSE);

  $results = $sal_query->execute();

  if (!$results->hasMoreResults()) {
    $finished = TRUE;
  }

  $collections = $results->getTingEntityCollections();
  foreach ($collections as $collection) {
    foreach ($collection->getEntities() as $entity) {
      $entity_id = $entity->getId();
      $entities[$entity_id] = ding_entity_load($entity_id, 'ting_object');
    }
  }

  // See what materials have covers.
  $covers = ting_covers_get(array_keys($entities));

  // Loop over the fetched covers and build items.
  foreach ($covers as $id => $path) {
    $entities_found_with_covers[$id] = $entities[$id];
  }

  return array($entities_found_with_covers, $start, $finished);
}

/**
 * Implements hook_image_default_styles().
 */
function bbs_search_carousel_image_default_styles() {
  return array(
    'bbs_search_carousel' => array(
      'name' => 'bbs_search_carousel',
      'effects' => array(
        array(
          'label' => 'Scale and crop',
          'effect callback' => 'image_scale_and_crop_effect',
          'dimensions callback' => 'image_resize_dimensions',
          'module' => 'image',
          'name' => 'image_scale_and_crop',
          'data' => array(
            'width' => '200',
            'height' => '290',
          ),
          'weight' => '1',
        ),
      ),
    ),
  );
}
